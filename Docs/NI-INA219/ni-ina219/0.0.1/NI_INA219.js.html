

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      NI_INA219.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      WaveShare-UPS INA219
    </h3>

    

    <h3>Classes</h3><ul><li id="I2cBus-nav"><a href="I2cBus.html">I2cBus</a><ul class='methods'><li data-type="method" id="I2cBus-initialize-nav"><a href="I2cBus.html#initialize">initialize</a></li><li data-type="method" id="I2cBus-setCurrentBusData-nav"><a href="I2cBus.html#setCurrentBusData">setCurrentBusData</a></li><li data-type="method" id="I2cBus-removeBus-nav"><a href="I2cBus.html#removeBus">removeBus</a></li><li data-type="method" id="I2cBus-readRegister-nav"><a href="I2cBus.html#readRegister">readRegister</a></li><li data-type="method" id="I2cBus-writeRegister-nav"><a href="I2cBus.html#writeRegister">writeRegister</a></li></ul></li><li id="BaseRegisterModel-nav"><a href="BaseRegisterModel.html">BaseRegisterModel</a><ul class='methods'><li data-type="method" id="BaseRegisterModel-hydrate-nav"><a href="BaseRegisterModel.html#hydrate">hydrate</a></li><li data-type="method" id="BaseRegisterModel-formatData-nav"><a href="BaseRegisterModel.html#formatData">formatData</a></li><li data-type="method" id="BaseRegisterModel-getCurrentValues-nav"><a href="BaseRegisterModel.html#getCurrentValues">getCurrentValues</a></li><li data-type="method" id="BaseRegisterModel-getCurrentValues-nav"><a href="BaseRegisterModel.html#getCurrentValues">getCurrentValues</a></li></ul></li><li id="BusVoltageModel-nav"><a href="BusVoltageModel.html">BusVoltageModel</a><ul class='methods'><li data-type="method" id="BusVoltageModel-calculateValue-nav"><a href="BusVoltageModel.html#calculateValue">calculateValue</a></li></ul></li><li id="CalibrationModel-nav"><a href="CalibrationModel.html">CalibrationModel</a></li><li id="ChargeRemainingModel-nav"><a href="ChargeRemainingModel.html">ChargeRemainingModel</a><ul class='methods'><li data-type="method" id="ChargeRemainingModel-formatData-nav"><a href="ChargeRemainingModel.html#formatData">formatData</a></li><li data-type="method" id="ChargeRemainingModel-calculateValue-nav"><a href="ChargeRemainingModel.html#calculateValue">calculateValue</a></li></ul></li><li id="ConfigurationModel-nav"><a href="ConfigurationModel.html">ConfigurationModel</a></li><li id="CurrentModel-nav"><a href="CurrentModel.html">CurrentModel</a><ul class='methods'><li data-type="method" id="CurrentModel-calculateValue-nav"><a href="CurrentModel.html#calculateValue">calculateValue</a></li></ul></li><li id="PowerModel-nav"><a href="PowerModel.html">PowerModel</a><ul class='methods'><li data-type="method" id="PowerModel-calculateValue-nav"><a href="PowerModel.html#calculateValue">calculateValue</a></li></ul></li><li id="PowerSupplyModel-nav"><a href="PowerSupplyModel.html">PowerSupplyModel</a><ul class='methods'><li data-type="method" id="PowerSupplyModel-formatData-nav"><a href="PowerSupplyModel.html#formatData">formatData</a></li><li data-type="method" id="PowerSupplyModel-calculateValue-nav"><a href="PowerSupplyModel.html#calculateValue">calculateValue</a></li></ul></li><li id="ShuntVoltageModel-nav"><a href="ShuntVoltageModel.html">ShuntVoltageModel</a><ul class='methods'><li data-type="method" id="ShuntVoltageModel-calculateValue-nav"><a href="ShuntVoltageModel.html#calculateValue">calculateValue</a></li></ul></li><li id="NI_INA219-nav"><a href="NI_INA219.html">NI_INA219</a><ul class='methods'><li data-type="method" id="NI_INA219-initialize-nav"><a href="NI_INA219.html#initialize">initialize</a></li><li data-type="method" id="NI_INA219-readRegister-nav"><a href="NI_INA219.html#readRegister">readRegister</a></li><li data-type="method" id="NI_INA219-writeRegister-nav"><a href="NI_INA219.html#writeRegister">writeRegister</a></li><li data-type="method" id="NI_INA219-setConfiguration-nav"><a href="NI_INA219.html#setConfiguration">setConfiguration</a></li><li data-type="method" id="NI_INA219-setCalibration-nav"><a href="NI_INA219.html#setCalibration">setCalibration</a></li><li data-type="method" id="NI_INA219-getConfiguration-nav"><a href="NI_INA219.html#getConfiguration">getConfiguration</a></li><li data-type="method" id="NI_INA219-getCalibration-nav"><a href="NI_INA219.html#getCalibration">getCalibration</a></li><li data-type="method" id="NI_INA219-getBusVoltage-nav"><a href="NI_INA219.html#getBusVoltage">getBusVoltage</a></li><li data-type="method" id="NI_INA219-getShuntVoltage-nav"><a href="NI_INA219.html#getShuntVoltage">getShuntVoltage</a></li><li data-type="method" id="NI_INA219-getPower-nav"><a href="NI_INA219.html#getPower">getPower</a></li><li data-type="method" id="NI_INA219-getCurrent-nav"><a href="NI_INA219.html#getCurrent">getCurrent</a></li><li data-type="method" id="NI_INA219-getPowerSupplyVoltage-nav"><a href="NI_INA219.html#getPowerSupplyVoltage">getPowerSupplyVoltage</a></li><li data-type="method" id="NI_INA219-getChargeRemaining-nav"><a href="NI_INA219.html#getChargeRemaining">getChargeRemaining</a></li></ul></li><li id="Utilities-nav"><a href="Utilities.html">Utilities</a><ul class='methods'><li data-type="method" id="Utilities-mappedLabelsAndBits-nav"><a href="Utilities.html#mappedLabelsAndBits">mappedLabelsAndBits</a></li><li data-type="method" id="Utilities-registerAsBinaryString-nav"><a href="Utilities.html#registerAsBinaryString">registerAsBinaryString</a></li></ul></li></ul><h3 id="global-nav"><a href="global.html">Global</a></h3>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        NI_INA219.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>// V@ts-check &lt;- has problems with 'this' in the init method for some reason
/**
 * @class NI_INA219
 * 
 * @summary 
 * (v.0.0.1) - WaveShare UPS Raspberry Pi Hat uses a TI INA219_sensor
 * 
 * @description 
 * Texas Instruments INA219 Zero-Drift Bi-Directional Current/Power 
 * monitor with I2c interface. 
 * 
 * &lt;br />&lt;br />
 * [INA219 Chip Specs]{@link https://www.waveshare.com/w/upload/1/10/Ina219.pdf}&lt;br />
 * [WaveShare UPS Product page]{@link https://www.waveshare.com/product/raspberry-pi/hats/ups-hat.htm}
 * &lt;br />&lt;br />
 * This library builds on these two versions:&lt;br />
 * &lt;br />
 * [WaveShare's Python demo code]{@link https://www.waveshare.com/wiki/UPS_HAT}&lt;br />
 * [nodejs version by brettmarl on GitHub]{@link https://github.com/brettmarl/node-ina219}
 * &lt;br />
 * &lt;br />
 * Uses [I2c-bus]{@link https://github.com/fivdi/i2c-bus} temporarily for developing - 
 * but will be removed once complete as the module should be provided a promise-based bus 
 * on instantiation.&lt;br />&lt;br />
 * 
 * Testing hardware:&lt;br /> 
 * 1 x Raspberry Pi 4b with the WaveShare UPS hat installed.&lt;br />
 * 2 x NCR18650B 18650 Battery&lt;br />&lt;br />
 * #note: Battery type Panasonic-Japan 3400mAh Li-ion 3.7V Flat Top Rechargeable [3.6 &lt;> 4.2 cutoff 2.5]&lt;br />
 * [specs]{@link https://www.orbtronic.com/content/NCR18650B-Datasheet-Panasonic-Specifications.pdf}&lt;br />
 */

import { Constants } from "./Constants/index.js";
import { Models } from "./Models/index.js";
import { outputAsJson } from "./Responder/index.js";

// 3rd party import
import I2CBus from "./Bus/I2C/index.js";

class NI_INA219 {

    /** @type {object | undefined} */
    currentConfiguration;

    /**
     * @method NI_INA219#initialize
     * 
     * @summary
     * Start register/calibrate bus &amp; sensor
     * 
     * @description 
     * Gets a handler to the INA219 chip via I2c.
     * On success configures the chip and runs an initial
     * calibration to ensure correct values on the 
     * register.
     * 
     * @async 
     * 
     * @param {Number} i2cAddress Address in hex of the sensor ie: 0x24
     * @param {Number} busNumber The Bus address as an integer ie: 1 ( for PI )
     * @param {*} configurationTemplateId Configuring the sensor and calibration template Id
     * @param {*} useLogging Not implemented
     * @param {*} loggingType Not implemented
     * @returns {Promise&lt;(ResultObject|ErrorResultObject)>}  returns value object 
     */
    initialize = async function (
        i2cAddress = Constants.DEFAULT_I2C_ADDRESS,
        busNumber = Constants.DEFAULT_I2C_BUS,
        configurationTemplateId = "32V2A",
        useLogging = false,
        loggingType = "VERBOSE"
    ) {

        // get handle to I2c bus and sensor
        let initI2cBus = await I2CBus.initialize(i2cAddress, busNumber);
        if (initI2cBus.success === false) return initI2cBus;

        // write the configuration to the chip register
        let writeConfiguration = await this.setConfiguration(configurationTemplateId);
        if (writeConfiguration.success === false) return writeConfiguration;

        // update class
        this.currentConfiguration = writeConfiguration.data;

        // write calibration values to the chip register
        let writeCalibration = await this.setCalibration();
        if (writeCalibration.success === false) return writeCalibration;

        return {
            success: true,
            msg: "[UPS BOARD] - Ready",
            data: {}
        }

    }

    /**
     * @method NI_INA219#readRegister
     * 
     * @summary
     * I2c read method wrapper
     * 
     * @description
     * Wrapper for reading on the I2c Bus. Some registers require a write to 
     * kickstart the measuring / calculation before it can be read
     * For now we re-run the calibration write prior to reading
     * The speed of the sample rate in the config should be ok for reading
     * the results post write
     * 
     * @async
     * @param {Number} register Address in hex of the Register to be read ie: 0x2
     * @returns {Promise&lt;(ResultObject|ErrorResultObject)>}  returns value object
     */
    readRegister = async function (register) {
        // trigger fresh calcs
        let writeData = await this.setCalibration();
        if (writeData.success === false) return writeData;

        // read values
        let readData = await I2CBus.readRegister(register);
        if (readData.success === false) return readData;

        return readData;
    }

    /**
     * @method NI_INA219#writeRegister
     * 
     * @summary
     * I2c write method wrapper
     * 
     * @description
     * Wrapper into the I2c lib to allow refactoring
     * 
     * @async
     * @param {Number} register Address in hex of the Register to write ie: 0x2
     * @param {*} value What to write to the Register
     * @returns {Promise&lt;(ResultObject|ErrorResultObject)>}  returns value object
     */
    writeRegister = async function (register, value) {
        return await I2CBus.writeRegister(register, value);
    }

    /**
     * @method NI_INA219#setConfiguration
     *
     * @summary
     * Write the configuration the the Chip register 
     * 
     * @description
     * Uses a template Id to select from pre-made system configurations
     * and calculation values. Currently only "32V2A" ( 32 volts and 2 amps )
     * is available
     * 
     * @param {string} configurationTemplateId
     * 
     * @async
     * @returns {Promise&lt;(ResultObject|ErrorResultObject)>} returns value object 
     */
    setConfiguration = async function (configurationTemplateId = "32V2A") {

        let allTemplateIds = Constants.CALIBRATION_TEMPLATES.IDS;
        let allTemplates = Constants.CALIBRATION_TEMPLATES;
        let registerAddress = Constants.REGISTERS.CONFIG_RW;
        let writeResult = {};

        if (!allTemplateIds.includes(configurationTemplateId)) {
            return {
                success: false,
                msg: "Unknown configuration template Id",
                data: {
                    requestedId: configurationTemplateId
                }
            };
        } else {
            writeResult = await I2CBus.writeRegister(
                registerAddress,
                allTemplates[configurationTemplateId].config);
        }

        writeResult.data = (writeResult.success) ? allTemplates[configurationTemplateId] : writeResult.data;
        return writeResult;
    }

    /**
     * @method NI_INA219#setCalibration
     * 
     * @summary
     * Write the calibration value the the Chip register 
     * 
     * @description
     * When the system board settings are saved in the configuration 
     * register, we get back calibration and measurement values that
     * we can use to calibrate the results. This method also can be 
     * used along with reading Power to trigger the main read register
     * to calculate fresh values.
     * 
     * @async
     * @returns {Promise&lt;(ResultObject|ErrorResultObject)>} returns value object 
     */
    setCalibration = async function () {
        return await I2CBus.writeRegister(Constants.REGISTERS.CALIBRATION_RW, this.currentConfiguration.calValue);
    }

    /**
     * @method NI_INA219#getConfiguration
     * 
     * @summary
     * Read UPS Board's settings register
     * 
     * @description
     * Read the INA219 sensor chip settings from the I2c bus on the UPS board.
     * This is a method an external program would call.
     * 
     * @async
     * @returns {Promise&lt;(ResultObject|ErrorResultObject)>} returns value object
     */
    getConfiguration = async function () {
        let readResult = await this.readRegister(Constants.REGISTERS.CONFIG_RW);
        if (readResult.success === true) {
            Models.configuration.hydrate(readResult.data, "en", true);
            return outputAsJson(Models.configuration.getCurrentValues(), {});
        } else {
            return readResult;
        }
    }

    /**
     * @method NI_INA219#getCalibration
     * 
     * @summary
     * Read UPS Board's calibration register
     * 
     * @description
     * Read the INA219 sensor chip calibration register from the I2c bus on the UPS board.
     * This is a method an external program would call.
     * 
     * @async
     * @returns {Promise&lt;(ResultObject|ErrorResultObject)>}  returns value object
     */
    getCalibration = async function () {
        let readResult = await this.readRegister(Constants.REGISTERS.CALIBRATION_RW);
        if (readResult.success === true) {
            Models.calibration.hydrate(readResult.data, "en", true);
            return outputAsJson(Models.calibration.getCurrentValues(), {});
        } else {
            return readResult;
        }
    }

    /**
     * @method NI_INA219#getBusVoltage
     * 
     * @summary
     * Read the INA219 bus voltage measurement
     * 
     * @description
     * Read the INA219 sensor chip register where the bus voltage has been stored
     * from the I2c bus on the UPS board.
     * This is a method an external program would call.
     * 
     * @async
     * @returns {Promise&lt;(ResultObject|ErrorResultObject)>}  returns value object
     */
    getBusVoltage = async function () {
        let readResult = await this.readRegister(Constants.REGISTERS.BUS_VOLTAGE_R);
        if (readResult.success === true) {
            Models.busVoltage.hydrate(readResult.data, "en", true);
            return outputAsJson(Models.busVoltage.getCurrentValues(), {});
        } else {
            return readResult;
        }
    }

    /**
     * @method NI_INA219#getShuntVoltage
     * 
     * @summary
     * Read the INA219 shunt voltage measurement
     * 
     * @description
     * Read the INA219 sensor chip register where the shunt voltage has been stored
     * from the I2c bus on the UPS board.
     * This is a method an external program would call.
     * 
     * @async
     * @returns {Promise&lt;(ResultObject|ErrorResultObject)>}  returns value object
     */
    getShuntVoltage = async function () {
        let readResult = await this.readRegister(Constants.REGISTERS.SHUNT_VOLTAGE_R);
        if (readResult.success === true) {
            Models.shuntVoltage.hydrate(readResult.data, "en", true);
            return outputAsJson(Models.shuntVoltage.getCurrentValues(), {});
        } else {
            return readResult;
        }
    }

    /**
     * @method NI_INA219#getPower
     * 
     * @summary
     * Read the INA219 power measurement
     * 
     * @description
     * Read the INA219 sensor chip register where the Power measurement has been stored
     * from the I2c bus on the UPS board.
     * This is a method an external program would call.
     * 
     * @async
     * @returns {Promise&lt;(ResultObject|ErrorResultObject)>}  returns value object
     */
    getPower = async function () {
        let readResult = await this.readRegister(Constants.REGISTERS.POWER_R);
        if (readResult.success === true) {
            Models.power.hydrate(readResult.data, "en", true, {
                powerLSB: this.currentConfiguration.powerLSB
            });
            return outputAsJson(Models.power.getCurrentValues(), {});
        } else {
            return readResult;
        }
    }

    /**
     * @method NI_INA219#getCurrent
     * 
     * @summary
     * Read the INA219 Current measurement
     * 
     * @description
     * Read the INA219 sensor chip register where the Current measurement has been stored
     * from the I2c bus on the UPS board.
     * This is a method an external program would call.
     * 
     * @async
     * @returns {Promise&lt;(ResultObject|ErrorResultObject)>}  returns value object
     */
    getCurrent = async function () {
        let readResult = await this.readRegister(Constants.REGISTERS.CURRENT_R);
        if (readResult.success === true) {
            Models.current.hydrate(readResult.data, "en", true, {
                currentLSB: this.currentConfiguration.currentLSB
            });
            return outputAsJson(Models.current.getCurrentValues(), {});
        } else {
            return readResult;
        }
    }

    /**
     * @method NI_INA219#getPowerSupplyVoltage
     * 
     * @summary
     * Custom calculation based on demo code in WaveShare
     * 
     * @description
     * In the WaveShare Wiki for this HAT there is a commented out measurement for 
     * returning the PSU voltage. They calculate it as the Bus Voltage + Shunt Voltage.
     * This method is here for functional parity. If not using this hat, can ignore.
     * 
     * @async
     * @returns {Promise&lt;(ResultObject|ErrorResultObject)>}  returns value object
     */
    getPowerSupplyVoltage = async function () {
        let busVoltage = await this.getBusVoltage();
        let shuntVoltage = await this.getShuntVoltage();
        Models.powerSupplyModel.hydrate(
            {
                busVoltage: busVoltage,
                shuntVoltage: shuntVoltage
            },
            "en",
            true
        );
        return outputAsJson(Models.powerSupplyModel.getCurrentValues(), {});
    }

    /**
     * @method NI_INA219#getChargeRemaining
     * 
     * @summary
     * Custom calculation based on demo code in WaveShare
     * 
     * @description
     * In the WaveShare Wiki for this HAT there is a commented out measurement for 
     * returning the PSU voltage. They calculate it as the Bus Voltage + Shunt Voltage.
     * This method is here for functional parity. If not using this hat, can ignore.
     * 
     * @async
     * @returns {Promise&lt;(ResultObject|ErrorResultObject)>}  returns value object
     */
    getChargeRemaining = async function () {
        let busVoltage = await this.getBusVoltage();
        if (busVoltage.success === true) {
            Models.chargeRemainingModel.hydrate(busVoltage.data, "en", true);
            return outputAsJson(Models.chargeRemainingModel.getCurrentValues(), {});
        } else {
            return readResult;
        }
    }

}

export default new NI_INA219();</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>
